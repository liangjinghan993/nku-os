# Lab0.5 实验报告

## 练习1：使用GDB验证启动流程

为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。

加电后，`RISC-V`会复位到地址 0x1000 处（`reset vector （复位向量）` 的地址宏定义为 0x1000，又将`reset vector`赋值给 `pc`，说明开机后的复位地址为 0x1000）

5条汇编语言：

> `auipc t0,0x0`
>
> 功能及含义：它将立即数（指 0x0）扩展 32 位并加到当前指令地址的高 20 位上，并将结果存储在寄存器 `t0` 中。此时 `t0` 的值是 0x1000。

> `addi a1,t0,32`
>
> 功能及含义：它将寄存器 `t0` 中的值和立即数（此处指 32）相加，并把结果存储在寄存器 `a1` 中。此时 `a1` 的值是0x1020.

> `csrr a0,mhartid`
>
> 功能及含义：CSRR：这是一个特权级别下的指令，用于读取 CSR（Control and Status Register，控制和状态寄存器）的值。
>
> 该语句读取控制和状态寄存器（`CSR`）中的 `mhartid` 寄存器的值，并将结果存储在寄存器 `a0` 中。`mhartid` 寄存器通常包含处理器的硬件线程 `ID`。此时 `a0` 值为 0
>
> *   a0：这是目标寄存器，将 hart ID 的值加载到这个寄存器中。
> *   mhartid：这是 CSR 的名称，它存储着当前核心的 hart ID。

> `ld t0, 24(t0)`
>
> 功能及含义：从寄存器t0中取出一个地址，然后加上偏移量24，然后将结果作为一个新的地址再次存储回寄存器t0。此时 t0 的值是0x80000000

> `jr t0`
>
> 功能及含义：将寄存器 `t0` 中的值解释为跳转目标地址，并跳转到该地址。此时完成了地址转换

这段代码完成了将 `PC` 寄存器跳转到 0x80000000 处。0x80000000 处通过 `QEMU` 自带的 `bootloader--OpenSBI` 固件，将两个文件被加载到 `Qemu` 的物理内存中：即作为 `bootloader` 的 `OpenSBI.bin` 被加载到物理内存以物理地址 0x80000000 开头的区域上，同时内核镜像 `os.bin` 被加载到以物理地址 0x80200000 开头的区域上。

QEMU窗口：

![](https://gitee.com/liang-jinghan888/nku-operating-system-2023/raw/master/%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9/0.5-1.png)

kern/init/entry.S是内核的入口点，这个入口点调用了kern\_init函数，kern\_init位于kern/init/init.c中，其作用是打印出一串字符串，然后进入一个while的死循环，完成RISCV的启动。

*   在Lab0的文件夹打开终端，执行make debug，打开另一个终端，执行make gdb
*   x/10i 0x80000000显示0x80000000处的十条汇编代码，使用命令x/10i \$pc显示即将执行的10条汇编指令。当前pc位于0x1000处，即复位地址为0x1000（而不是0x80000000）

![b39f2c54af28e195dd82564f41c5ec2.png](https://gitee.com/liang-jinghan888/nku-operating-system-2023/blob/master/%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9/0.5-2.png)

*   break \*0x80000000：在0x80000000处设置断点，continue执行命令直到断点，RISCV无任何变化，未执行kern\_init函数（事实上，OpenSBI.bin 被加载到物理内存以物理地址 0x80000000 开头的区域上）

![image.png](https://gitee.com/liang-jinghan888/nku-operating-system-2023/blob/master/%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%B9/0.5-3.png)

*   break \*0x80200000：在0x80200000处设置断点，continue执行命令直到断点，RISCV输出一串字符，执行了kern\_init函数，操作系统启动完成（内核镜像 os.bin 被加载到以物理地址 0x80200000 开头的区域上）

![image.png](https://note.youdao.com/yws/res/76/WEBRESOURCEdb39ba898d1b30714d60093fcabb646d)

## RISC-V加电后完成了哪些功能？

1.  **处理器复位**（ `Reset` ）：计算机的处理器（ `CPU` ）通常会处于复位状态。在复位状态下，`CPU` 的程序计数器（PC）被设置为一个特定的复位地址。

2.  **初始化内存**：本实验中执行 `memset` 函数时，对内存进行初始化，将内存区域的字节清零。

3.  **加载操作系统**： `BootLoader` 将操作系统加载到内存中并启动它，比如本实验中 `QEMU` 将 `os.bin` 内核镜像加载到相应物理地址。

4.  **跳转到程序入口点**：硬件通过执行跳转指令，将控制权转移到应用程序的入口点（本实验为 0x80200000 ）继续执行。

## 实验重要知识点

*   bootloader：操作系统本身不能将自己加载到内存里，需要bootloader来完成将操作系统加载到内存中的操作。它的主要任务是初始化系统硬件并启动操作系统内核。引导程序通常存储在系统的非易失性存储器中（如ROM、Flash等），并在系统上电时由硬件自动加载到内存中执行。
*   内存布局：一个程序按照功能不同会分为.text段（代码段）；.rodata段（只读数据段）；.data段（可读写数据段）；.bss段（存放被初始化为 00 的可读写数据）；stack ，即栈，用来存储程序运行过程中的局部变量，以及负责函数调用时的各种机制。它从高地址向低地址增长； heap ，即堆，用来支持程序运行过程中内存的动态分配。

![](https://gitee.com/nk-jj/os/raw/master/report/lab0.5_lab1/fig/0.5_4.png)  &#x20;

*   &#x20;RISC-V 中，入口函数的地址是固定的，通常是 0x80000000。处理器启动时，从该地址执行指令。本次实验中，复位地址为0x1000后经跳转至0x80000000处。入口函数源代码采用汇编语言编写，它需要直接访问硬件和内存，该函数会完成一下任务：1)初始化栈指针； 2)初始化全局变量； 3)初始化中断向量表； 4)初始化硬件设备； 5)加载操作系统到内存； 6)跳转到操作系统的入口点。

## OS原理重点

1.  进程管理：操作系统负责管理计算机上运行的各个进程。包括创建、调度、暂停、恢复和终止。操作系统需要确保进程之间的资源共享和互斥，以避免冲突和竞争条件。
2.  内存管理：操作系统管理计算机的物理和虚拟内存。它需要分配和回收内存，以便进程能够访问所需的内存空间，同时避免内存泄漏和碎片化。
3.  文件系统管理：操作系统负责管理文件和目录，包括文件的创建、读取、写入、删除和权限控制。它还需要确保数据的持久性和一致性。
4.  设备管理：操作系统与硬件设备进行通信，以管理输入输出（I/O）设备。这包括驱动程序的加载、设备的初始化、I/O队列的管理等。

